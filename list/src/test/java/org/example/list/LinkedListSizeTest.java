/*
 * This source file was generated by the Gradle 'init' task
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test gradle-nov-20 using AI Type Claude AI and AI Model claude-haiku-4-5-20251001

ROOST_METHOD_HASH=size_59c2ff4386
ROOST_METHOD_SIG_HASH=size_83d847afcf

Scenario 1: Size of an Empty LinkedList

Details:
  TestName: sizeOfEmptyLinkedList
  Description: This test verifies that the size() method returns zero when the LinkedList is empty. The head node is null, indicating no elements exist in the list. This is a fundamental edge case that ensures the method correctly handles the initial state of a LinkedList.

Execution:
  Arrange: Create a new LinkedList instance with head initialized to null (default state).
  Act: Invoke the size() method on the empty LinkedList.
  Assert: Assert that the returned size equals zero using assertEquals(0, linkedList.size()).

Validation:
  The assertion verifies that an empty LinkedList correctly reports a size of zero. This is critical for ensuring the method handles the base case properly and prevents incorrect size calculations when no elements are present in the list.

*/

// ********RoostGPT********

package org.example.list;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

@DisplayName("LinkedList Size Tests")
class LinkedListSizeTest {
    private LinkedList linkedList;
    @BeforeEach
    void setUp() {
        linkedList = new LinkedList();
    }
    @Test
    @Tag("boundary")
    @DisplayName("Size of an empty LinkedList should return zero")
    void sizeOfEmptyLinkedList() {
        // Arrange: LinkedList is initialized with head = null (default state)
        
        // Act: Invoke size() method on empty LinkedList
        int size = linkedList.size();
        
        // Assert: Verify that size equals zero
        assertEquals(0, size, "Empty LinkedList should have size of zero");
    }
    @Test
    @Tag("valid")
    @DisplayName("Size of LinkedList with single element should return one")
    void sizeOfSingleElementLinkedList() {
        // Arrange: Add one element to the LinkedList
        linkedList.add("Element1");
        
        // Act: Invoke size() method
        int size = linkedList.size();
        
        // Assert: Verify that size equals one
        assertEquals(1, size, "LinkedList with one element should have size of one");
    }
    @Test
    @Tag("valid")
    @DisplayName("Size of LinkedList with multiple elements should return correct count")
    void sizeOfMultipleElementsLinkedList() {
        // Arrange: Add multiple elements to the LinkedList
        linkedList.add("Element1");
        linkedList.add("Element2");
        linkedList.add("Element3");
        linkedList.add("Element4");
        linkedList.add("Element5");
        
        // Act: Invoke size() method
        int size = linkedList.size();
        
        // Assert: Verify that size equals five
        assertEquals(5, size, "LinkedList with five elements should have size of five");
    }
    @ParameterizedTest
    @ValueSource(ints = {1, 5, 10, 50, 100})
    @Tag("valid")
    @DisplayName("Size should correctly count elements for various list sizes")
    void sizeForVariousListSizes(int elementCount) {
        // Arrange: Add specified number of elements to the LinkedList
        for (int i = 0; i < elementCount; i++) {
            linkedList.add("Element" + i);
        }
        
        // Act: Invoke size() method
        int size = linkedList.size();
        
        // Assert: Verify that size equals the number of added elements
        assertEquals(elementCount, size, 
            "LinkedList with " + elementCount + " elements should have size of " + elementCount);
    }
    @Test
    @Tag("integration")
    @DisplayName("Size should update correctly after adding elements sequentially")
    void sizeUpdatesAfterSequentialAdditions() {
        // Arrange & Act & Assert: Add elements one by one and verify size after each addition
        assertEquals(0, linkedList.size(), "Initial size should be zero");
        
        linkedList.add("Element1");
        assertEquals(1, linkedList.size(), "Size should be one after first addition");
        
        linkedList.add("Element2");
        assertEquals(2, linkedList.size(), "Size should be two after second addition");
        
        linkedList.add("Element3");
        assertEquals(3, linkedList.size(), "Size should be three after third addition");
    }
    @Test
    @Tag("integration")
    @DisplayName("Size should update correctly after removing elements")
    void sizeUpdatesAfterRemoval() {
        // Arrange: Add multiple elements
        linkedList.add("Element1");
        linkedList.add("Element2");
        linkedList.add("Element3");
        assertEquals(3, linkedList.size(), "Initial size should be three");
        
        // Act & Assert: Remove elements and verify size updates
        linkedList.remove("Element1");
        assertEquals(2, linkedList.size(), "Size should be two after removing one element");
        
        linkedList.remove("Element2");
        assertEquals(1, linkedList.size(), "Size should be one after removing another element");
        
        linkedList.remove("Element3");
        assertEquals(0, linkedList.size(), "Size should be zero after removing all elements");
    }
    @Test
    @Tag("integration")
    @DisplayName("Size should remain unchanged when removing non-existent element")
    void sizeUnchangedWhenRemovingNonExistentElement() {
        // Arrange: Add elements to the LinkedList
        linkedList.add("Element1");
        linkedList.add("Element2");
        int initialSize = linkedList.size();
        
        // Act: Attempt to remove non-existent element
        linkedList.remove("NonExistent");
        
        // Assert: Verify size remains unchanged
        assertEquals(initialSize, linkedList.size(), 
            "Size should remain unchanged when removing non-existent element");
    }
    @Test
    @Tag("valid")
    @DisplayName("Size should handle LinkedList with duplicate elements")
    void sizeWithDuplicateElements() {
        // Arrange: Add duplicate elements to the LinkedList
        linkedList.add("Element1");
        linkedList.add("Element1");
        linkedList.add("Element1");
        linkedList.add("Element2");
        linkedList.add("Element2");
        
        // Act: Invoke size() method
        int size = linkedList.size();
        
        // Assert: Verify that size counts all elements including duplicates
        assertEquals(5, size, "Size should count all elements including duplicates");
    }
    @Test
    @Tag("valid")
    @DisplayName("Size should handle LinkedList with null-like string values")
    void sizeWithSpecialStringValues() {
        // Arrange: Add special string values
        linkedList.add("");
        linkedList.add("   ");
        linkedList.add("Special!@#$%");
        
        // Act: Invoke size() method
        int size = linkedList.size();
        
        // Assert: Verify that size counts all elements regardless of content
        assertEquals(3, size, "Size should count all elements regardless of string content");
    }
    @Test
    @Tag("integration")
    @DisplayName("Size should be consistent across multiple invocations")
    void sizeConsistencyAcrossMultipleInvocations() {
        // Arrange: Add elements to the LinkedList
        linkedList.add("Element1");
        linkedList.add("Element2");
        linkedList.add("Element3");
        
        // Act & Assert: Invoke size() multiple times and verify consistency
        int size1 = linkedList.size();
        int size2 = linkedList.size();
        int size3 = linkedList.size();
        
        assertEquals(size1, size2, "Size should be consistent across invocations");
        assertEquals(size2, size3, "Size should be consistent across invocations");
        assertEquals(3, size1, "Size should equal three");
    }
    @Test
    @Tag("boundary")
    @DisplayName("Size should handle large number of elements")
    void sizeWithLargeNumberOfElements() {
        // Arrange: Add a large number of elements
        int largeCount = 1000;
        for (int i = 0; i < largeCount; i++) {
            linkedList.add("Element" + i);
        }
        
        // Act: Invoke size() method
        int size = linkedList.size();
        
        // Assert: Verify that size correctly counts all elements
        assertEquals(largeCount, size, "Size should correctly count large number of elements");
    }
}